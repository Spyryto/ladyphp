<?php # DO NOT EDIT THIS FILE. It was generated by LadyPHP.

class Lady{


  # ---------------------------------------------
  # constants
  # ---------------------------------------------
  const REGEX_CODE = '/.*[^(<\?|<\?php)\{\} ].*/'  ;# some php code on line
  const REGEX_OPEN_TAG = '/^ *(<\?|<\?php)/'       ;# <? or <?php
  const REGEX_COMMENT = '/^ *(#|\/\/).*/'          ;# full line comment
  const REGEX_EMPTY = '/^ *$/'                     ;# only spaces
  const REGEX_ENDED = '/[;&\|,\.]$/'               ;# no semicolons after these
  const REGEX_CONTINUE = '/^[&\|\.]/'              ;# condition on multiple lines
  const REGEX_OPENING = '/(^[^(]*|.*\))$/'         ;# 'else' is opening
  const REGEX_VARIABLE = '/^[a-z].*/'              ;# variable name
  const REGEX_NOVARIABLE = '/^(false|true|self|null)$/' ;# not variables

  const PRESERVE = 0  ;# preserve code formating and comments
  const STRIP    = 1  ;# strip comments, keep line numbers
  const COMPRESS = 2  ;# compress output code

  const OUTPUT_HEAD = ' # DO NOT EDIT THIS FILE. It was generated by LadyPHP.';


  # ---------------------------------------------
  # parse
  # convert lady script to php
  # ---------------------------------------------
  static public function parse($source, $shrink = self::PRESERVE, $debug = false){
    $code = $dump = $noVar = null;
    $comment = array();

    # get tokens
    $tokens = token_get_all($source);

    # convert string tokens to arrays
    foreach ($tokens as $n => $token){
      if (!is_array($token)){
        $tokens[$n] = array(null, $token, null);}}
    
    # process tokens
    foreach ($tokens as $n => $token){
      list($name, $string, $line) = $token;

      # add $ to variables
      if ($name == T_STRING
          && $tokens[$n + 1][1] != '('
          && $tokens[$n - 1][1] != '->'
          && preg_match(self::REGEX_VARIABLE, $string)
          && !preg_match(self::REGEX_NOVARIABLE, $string)){
        $code .= '$' . $string;}

      # strip comments
      elseif ($name == T_COMMENT){
        $comments[$line - 1] = $string;
        if (substr($string, -1) == "\n"){
          $code .= "\n";}}

      # convert php open tag
      elseif ($name == T_OPEN_TAG){
        $code .= '<?php';
        if ($line == 1){
          $code .= self::OUTPUT_HEAD;}}

      # just copy
      else{
        $code .= $string;}

      # save token dump
      $dump .= $n . '. ' . $name . ': ' . $string . "\n";}
    

    # lines
    $lines = explode("\n", $code);
    $indent = 0;

    # shrink lines
    $i = 0;
    foreach ($lines as $n => $line){
      if (!isset($emptyLines[$i])){
        $emptyLines[$i] = null;}
      if (preg_match(self::REGEX_CODE, $line)){
        $shrinkedLines[$i] = $line;
        $i++;}
      else {
        $emptyLines[$i] .= $line . "\n";}}
    $shrinkedLines[] = 'true;';
    $lines = $shrinkedLines;

    # edit lines
    foreach ($lines as $n => $line){
      if (preg_match(self::REGEX_CODE, $line)
          && !preg_match(self::REGEX_CONTINUE, trim($line))){
        $indentBefore = $indent;
        $indent = (strlen($line) - strlen(ltrim($line))) / 2;
        $jump = $indent - $indentBefore;}
      else {
        $jump = 0;}

      # trim spaces
      $spaceBefore = str_repeat(' ', strlen($line) - strlen(ltrim($line)));
      $spaceAfter = str_repeat(' ', strlen($line) - strlen(rtrim($line)));
      $line = trim($line);

      # add semicolon
      if ($jump <= 0 
          && $n > 0
          && !preg_match(self::REGEX_CONTINUE, $line)
          && preg_match(self::REGEX_CODE, $lines[$n - 1])
          && !preg_match(self::REGEX_OPEN_TAG, $lines[$n - 1])
          && !preg_match(self::REGEX_COMMENT, $lines[$n - 1])
          && !preg_match(self::REGEX_ENDED, $lines[$n - 1])
          && !preg_match(self::REGEX_EMPTY, $lines[$n - 1])){
        $lines[$n - 1] .= ';';}

      # add opening bracket
      if ($jump > 0 && $n > 0
          && preg_match(self::REGEX_OPENING, $lines[$n - 1])){
        $lines[$n - 1] .= '{';}

      # add closing brackets
      if ($jump < 0){
        $lines[$n - 1] .= str_repeat('}', -$jump);}

      # add spaces
      if ($shrink < self::STRIP){
        $line = $spaceBefore . $line . $spaceAfter;}

      # change line
      $lines[$n] = $line;}

    # add empty lines
    foreach ($lines as $n => $line){
      $lines[$n] = $emptyLines[$n] . $lines[$n];}

    # reindex lines
    $lines = explode("\n", implode("\n", $lines));

    # add comments (PRESERVE)
    if ($shrink < self::STRIP){
      foreach ($lines as $n => $line){
        if (isset($comments[$n])){
          $lines[$n] = $lines[$n] . rtrim($comments[$n]);}}}

    # trim spaces (STRIP and COMPRESS)
    else{
      foreach ($lines as $n => $line){
        $lines[$n] = rtrim($line, ' ');}}

    # format code
    $code = implode("\n", array_slice($lines, 0, -1));

    # minify code (COMPRESS)
    if ($shrink >= self::COMPRESS){
      $code = self::compress($code);}

    # output
    return $debug ? $dump : $code;}
  

  # ---------------------------------------------
  # parseFile
  # load file and parse it
  # ---------------------------------------------
  static public function parseFile($file, $shrink = self::PRESERVE, $debug = false){
    return self::parse(file_get_contents($file), $shrink, $debug);}
  

  # ---------------------------------------------
  # includeFile
  # parse file and execute it
  # ---------------------------------------------
  static public function includeFile($file){
    ob_start();
    eval('?>' . self::parseFile($file));
    return ob_get_clean();}
  

  # ---------------------------------------------
  # test
  # format html code from source and result
  # ---------------------------------------------
  static public function test($file, $shrink = self::PRESERVE, $debug = false){
    $source = file_get_contents($file);
    $output = self::parseFile($file, $shrink, $debug);
    $source = htmlspecialchars($source);
    $output = htmlspecialchars($output);
    return '<pre>' . $source . '</pre><hr><pre>' . $output . '</pre>';}


  # ---------------------------------------------
  # compress
  # strip comments and compress php source
  # ---------------------------------------------
  static public function compress($input){
    if (!defined('T_DOC_COMMENT')){
      define('T_DOC_COMMENT', -1);}
    if (!defined('T_ML_COMMENT')){
      define('T_ML_COMMENT', -1);}

    $space = $output = '';
    $set = '!"#$&\'()*+,-./:;<=>?@[\]^`{|}';
    $set = array_flip(preg_split('//',$set));

    foreach (token_get_all($input) as $token){
      if (!is_array($token)){
        $token = array(0, $token);}

      if (in_array($token[0], array(T_COMMENT, T_ML_COMMENT, T_DOC_COMMENT, T_WHITESPACE))){
        $space = ' ';}
      else{
        if (isset($set[substr($output, -1)]) || isset($set[$token[1]{0}])){
          $space = '';}
        $output .= $space . $token[1];
        $space = '';}}
    return $output;}}

