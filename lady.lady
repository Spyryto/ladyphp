<?

/**
 * LadyPHP - type PHP with elegance
 * @link http://github.com/unu/ladyphp
 * @author unumin
 * @license http://sam.zoy.org/wtfpl/COPYING
 */

/**
 * Converts LadyPHP code to PHP and works as stream wrapper.
 */
class Lady

  const REGEX_CLASS = ';^([A-Z].*|self|parent)$;'
  const REGEX_VARIABLE = ';^[_a-z].*$;'
  const REGEX_NOVARIABLE = ';^(false|true|self|parent|null)$;'
  const JOINING = '&& || & | -> . + - , / * % = ? :'
  const ENDING = ' ; { } ( array( [ <?' # do not add ; { } after these
  const CONTINUING = ') ]' # line is continuing if starts with these
  var buffer, position, filename, cacheFile

  static head = '/* Generated by LadyPHP */'
  static cacheDir

  /**
   * Loads file and parses it.
   * @param string File to parse
   * @param bool Expanded output
   * @return string PHP code
   */
  static fn parseFile(filename, expanded = false)
    return self.parse(file_get_contents(filename), expanded)

  /**
   * Parses LadyPHP from string to PHP code
   * @param string LadyPHP code
   * @param bool Expanded output
   * @return string PHP code
   */
  static fn parse(source, expanded = false)
    source = str_replace("\r", '', source)
    openingBracket = false
    closingBrackets = []
    closingIndentStr = []
    squareBrackets = 0
    arrayBrackets = []

    # process tokens
    tokens = self.tokenize(source)
    foreach (tokens as n: token)
      token = tokens[n]
      extract(token, EXTR_OVERWRITE | EXTR_REFS)

      # skip last dummy token
      if (n > count(tokens) - 2)
        break

      # square brackets to array()
      elseif (str == '[')
        squareBrackets++
        if (hasBlank || in_array(tokens[n - 1]['str'], explode(' ', self.JOINING .. ' ' .. self.ENDING)))
          str = 'array('
          arrayBrackets[squareBrackets] = true

      elseif (str == ']')
        if (isset(arrayBrackets[squareBrackets]) && arrayBrackets[squareBrackets])
          str = ')'
          arrayBrackets[squareBrackets] = false
        squareBrackets--

      # convert 'fn' to 'function'
      elseif (str == 'fn')
        str = 'function'

      # convert . to -> or :: and .. to .
      elseif (str == '.')
        if (tokens[n + 1]['str'] == '.')
          tokens[n + 1]['str'] = ''
        elseif (!hasBlank || !tokens[n + 1]['hasBlank'])
          if (preg_match(self.REGEX_CLASS, tokens[n - 1]['str']))
            str = '::'
          else
            str = '->'

      # convert : to =>
      elseif (str == ':' && !hasBlank && !isLast)
        str = ' =>'

      # add $ before variables
      elseif (type == T_STRING
          && tokens[n + 1]['str'] != '('
          && tokens[n - 1]['str'] != '->'
          && preg_match(self.REGEX_VARIABLE, str)
          && !preg_match(self.REGEX_NOVARIABLE, str))
        str = '$' .. str

      # add 'new' before 'Foo\Bar()'
      i = 0
      while (((tokens[n + i]['type'] == T_STRING
          && preg_match(self.REGEX_CLASS, tokens[n + i]['str']))
          || tokens[n + i]['type'] == T_NS_SEPARATOR)
          && !in_array(tokens[n - 1]['type'], [T_STRING, T_NS_SEPARATOR])
          && (!tokens[n + i]['hasBlank'] || i == 0)
          && tokens[n - 1]['type'] != T_NEW)
        if (tokens[n + i]['type'] == T_STRING
            && tokens[n + i + 1]['str'] == '(')
          str = 'new ' .. str
          break
        i++

      # add semicolon and brackets
      if (isLast && !in_array(type, [T_OPEN_TAG, T_OPEN_TAG_WITH_ECHO, T_CLOSE_TAG])
          && !in_array(str, explode(' ', self.JOINING .. ' ' .. self.ENDING)))

        # sort list of closing brackets
        closingBrackets = array_unique(closingBrackets)
        rsort(closingBrackets)

        # switch block
        isSwitch = false
        i = 0
        while (isset(tokens[n - i]['y'])
            && tokens[n - i]['y'] == y)
          if (in_array(tokens[n - i]['type'], [T_CASE, T_DEFAULT]))
            isSwitch = true
            break
          i++
        if (isSwitch)
          str .= ':'

        # next line is indented
        elseif (tokens[n + 1]['indent'] > indent)

          # add opening bracket
          if (!in_array(tokens[n + 1]['str'], explode(' ', self.JOINING .. ' ' .. self.CONTINUING)))
            str .= '{'
            closingBrackets[] = indent
            closingIndentStr[indent] = indentStr
            openingBracket = false
          # save opening bracket
          else
            openingBracket = indent

        # line doesn't continue
        elseif (!in_array(tokens[n + 1]['str'], explode(' ', self.JOINING .. ' ' .. self.CONTINUING)))
          # there is saved opening bracket
          if (openingBracket !== false
              && tokens[n + 1]['indent'] > openingBracket)
            str .= '{'
            closingBrackets[] = openingBracket
            openingBracket = false
          # add semicolon
          else
            str .= ';'

        # add closing brackets
        if (indent > tokens[n + 1]['indent'])
          while (isset(closingBrackets[0])
              && closingBrackets[0] >= tokens[n + 1]['indent'])
            if (expanded)
              str .= "\n" .. closingIndentStr[closingBrackets[0]]
            str .= '}'
            closingBrackets = array_slice(closingBrackets, 1)

      # convert php open tags
      if (type == T_OPEN_TAG)
        if (!strstr(str, 'php'))
          str = str_replace('?', '?php ', str)
        if (y == 0)
          str = str_replace('php', 'php ' .. self.head, str)
      if (type == T_OPEN_TAG_WITH_ECHO)
        str = str_replace('<?=', '<?php echo ', str)

      # save token
      tokens[n] = token

    # glue code
    code = null
    foreach (tokens as token)
      code .= token['blank'] .. token['str']

    # return
    return code

  /**
   * Tokenizes source code and extends tokens.
   * @param string LadyPHP code
   * @return array Tokens
   */
  static fn tokenize(source)

    # replace open short tags to full ones
    if (!function_exists('ini_get') || !ini_get('short_open_tag'))
      do
        changed = false
        tokens = token_get_all(source)
        source = null
        foreach (tokens as n: token)
          token = is_array(token) ? token : [null, token]
          if (!changed && token[0] == T_INLINE_HTML)
            if (strpos(token[1], '<?=') !== false)
              position = strpos(token[1], '<?=')
              source .= substr_replace(token[1], '<?php echo ', position, 3)
              changed = true
            elseif (strpos(token[1], '<?') !== false)
              position = strpos(token[1], '<?')
              source .= substr_replace(token[1], '<?php ', position, 2)
              changed = true
            else
              source .= token[1]
          else
            source .= token[1]
      while (changed)

    # prepare tokens
    tokens = []
    blank = null
    foreach (token_get_all(source) as n: token)

      # convert to associative array
      if (is_array(token))
        token = ['str': token[1], 'type': token[0]]
      else
        token = ['str': token, 'type': null]

      # save whitespaces and comments into tokens
      if (in_array(token['type'], [T_COMMENT, T_DOC_COMMENT, T_WHITESPACE, T_INLINE_HTML]))
        blank .= token['str']
      else
        token['blank'] = blank
        token['hasBlank'] = (blank != null)
        blank = null
        tokens[] = token

    # save remaining blank
    tokens[] = ['str': null, 'type': null, 'blank': blank, 'isLast': true]

    # get positions
    foreach (tokens as n: token)
      token['n'] = n
      if (n == 0)
        token['indent'] = token['x'] = token['y'] = 0
        token['isFirst'] = true
      else
        blankRow = array_slice(explode("\n", token['blank']), -1)
        token['y'] = tokens[n - 1]['y'] + count(explode("\n", tokens[n - 1]['str'] .. token['blank'])) - 1
        token['isFirst'] = tokens[n - 1]['isLast'] = (tokens[n - 1]['y'] != token['y'])
        token['x'] = mb_strlen(blankRow[0])
        token['x'] += !token['isFirst'] ? tokens[n - 1]['x'] + mb_strlen(tokens[n - 1]['str']) : null
        token['indent'] = token['isFirst'] ? token['x'] : tokens[n - 1]['indent']
        token['indentStr'] = token['isFirst'] ? blankRow[0] : tokens[n - 1]['indentStr']
      tokens[n] = token

    return tokens

  /**
   * Converts changed or new .lady files in directory to .php files.
   * @param string Directory containing .lady files
   * @param bool Recursive search
   * @return array List of generated files
   */
  static fn convert(dir, recursive = false, expanded = false)
    files = []
    it = RecursiveDirectoryIterator(realpath(dir))
    if (recursive)
      it = RecursiveIteratorIterator(it)
    while (it.valid())
      if (!it.isDot() && it.isFile()
          && pathinfo(it.key(), PATHINFO_EXTENSION) == 'lady')
        phpFile = substr(it.key(), 0, -5) .. '.php'
        if (!is_file(phpFile) || filemtime(phpFile) < filemtime(it.key()))
          file_put_contents(phpFile, self.parseFile(it.key(), expanded))
          files[] = phpFile
      it.next()
    return files

  /**
   * Watches directory and converts changed or new .lady files to .php files.
   * @param string Directory to watch
   * @param bool Recursive search
   */
  static fn watch(dir, recursive = false, expanded = false)
    while (true)
      files = self.convert(dir, recursive, expanded)
      foreach (files as file)
        echo date("H:i:s") .. ' ' .. file .. "\n"
      usleep(500000)

  /**
   * Registers wrapper for lady:// and returns path to converted file.
   * @param string
   * @return string
   */
  static fn getFile(filename)
    if (!in_array('lady', stream_get_wrappers()))
      stream_wrapper_register('lady', __CLASS__)
    return 'lady://' .. filename

  /**
   * Opens file and uses cache.
   * @param string Directory for cache files
   * @return bool File was loaded
   */
  fn stream_open(filename)
    this.filename = realpath(str_replace('lady://', '', filename))
    this.position = 0
    if (!is_file(this.filename))
      return false
    if (!self.cacheDir)
      self.cacheDir = sys_get_temp_dir() .. '/ladyphp-' .. sha1(realpath(__FILE__))
    if (!is_dir(self.cacheDir))
      mkdir(self.cacheDir, 0755, true)
    this.cacheFile = self.cacheDir .. '/' .. sha1(this.filename) .. '.php'
    if (!is_file(this.cacheFile) || filemtime(this.cacheFile) <= filemtime(this.filename))
      code = self.parseFile(this.filename)
      this.buffer = null
      foreach (token_get_all(code) as token)
        if (token[0] == T_FILE)
          this.buffer .= var_export(this.filename, true)
        elseif (token[0] == T_DIR)
          this.buffer .= var_export(dirname(this.filename), true)
        else
          this.buffer .= is_array(token) ? token[1] : token
      file_put_contents(this.cacheFile, this.buffer)
    else
      this.buffer = file_get_contents(this.cacheFile)
    return is_string(this.buffer)

  /**
   * Read bytes from file.
   * @param int
   * @return string
   */
  fn stream_read(count)
    this.position += count
    return substr(this.buffer, this.position - count, count)

  /**
   * Returns true if file pionter is at EOF.
   * @return bool
   */
  fn stream_eof()
    return this.position >= strlen(this.buffer)

  /**
   * Returns info about file.
   * @return array
   */
  fn stream_stat()
    return ['size': strlen(this.buffer), 'mode': 0100644]

  /**
   * Returns info about file.
   * @return array
   */
  fn url_stat()
    return this.stream_stat()

/**
 * Shortcut function.
 */
if (!function_exists('lady'))
  fn lady(filename)
    return Lady::getFile(filename)

/**
 * Parses parameters from command line.
 */
if (isset(argv[1]) && realpath(argv[0]) == realpath(__FILE__))
  opts = getopt('i:o:c::w::er')
  if (isset(opts['i']))
    output = Lady.parseFile(opts['i'], isset(opts['e']))
    if (isset(opts['o']))
      file_put_contents(opts['o'], output)
    else
      echo output
  elseif (isset(opts['c']))
    echo implode("\n", Lady.convert(opts['c'], isset(opts['r']), isset(opts['e']))) .. "\n"
  elseif (isset(opts['w']))
    Lady.watch(opts['w'], isset(opts['r']), isset(opts['e']))
