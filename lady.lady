<?

class Lady

  # ---------------------------------------------
  # constants
  # ---------------------------------------------
  const ENDED_LINE = '; { ( [ . + - , / * % = <?'  # ended line
  const CONTINUING_LINE = '&& || & | . + , ] ) }'  # continuing line
  const REGEX_CLASS = ';^([A-Z].*|self|parent)$;'  # class name
  const REGEX_VARIABLE = ';^[_a-z].*;'             # variable name
  const REGEX_NOVARIABLE = ';^(false|true|self|parent|null)$;'  # not variables
  const OUTPUT_HEAD = '/* DO NOT EDIT THIS FILE. It was generated by LadyPHP. */'
  const COMPRESS = 1   # compress output code
  const NOCACHE  = 2   # always overwrite cache file

  # ---------------------------------------------
  # parse
  # convert LadyPHP from string to PHP code
  # ---------------------------------------------
  static fn parse(source, flags = 0)
    source = str_replace("\r", '', source)
    tokens = self.tokenize(source)
    openingBracket = false
    closingBrackets = []

    # process tokens
    foreach (tokens as n => token)
      extract(token, EXTR_OVERWRITE | EXTR_REFS)

      # skip last dummy token
      if (n > count(tokens) - 2)
        break

      # convert 'fn' to 'function'
      if (str == 'fn')
        str = 'function'

      # convert . to -> or ::
      elseif (str == '.'
          && (!hasBlank || !tokens[n + 1]['hasBlank']))
        if (preg_match(self.REGEX_CLASS, tokens[n - 1]['str']))
          str = '::'
        else
          str = '->'

      # convert : to =>
      elseif (str == ':' && !hasBlank && !isLast)
        str = ' =>'

      # add $ to variables
      elseif (type == T_STRING
          && tokens[n + 1]['str'] != '('
          && tokens[n - 1]['str'] != '->'
          && preg_match(self.REGEX_VARIABLE, str)
          && !preg_match(self.REGEX_NOVARIABLE, str))
        str = '$' . str

      # add 'new' before 'Foo()', support for namespaces
      i = 0
      while (((tokens[n + i]['type'] == T_STRING
          && preg_match(self.REGEX_CLASS, tokens[n + i]['str']))
          || tokens[n + i]['type'] == T_NS_SEPARATOR)
          && hasBlank
          && (!tokens[n + i]['hasBlank'] || i == 0)
          && tokens[n - 1]['type'] != T_NEW)
        if (tokens[n + i]['type'] == T_STRING
            && tokens[n + i + 1]['str'] == '(')
          str = 'new ' . str
          break
        i++

      # add semicolon or brackets
      if (isLast
          && !in_array(str, explode(' ', self.ENDED_LINE))
          && type != T_CLOSE_TAG)

        # sort list of closing brackets
        closingBrackets = array_unique(closingBrackets)
        rsort(closingBrackets)

        # switch block
        isSwitch = false
        i = 0
        while (isset(tokens[n - i]['y'])
            && tokens[n - i]['y'] == y)
          if (in_array(tokens[n - i]['type'], [T_CASE, T_DEFAULT]))
            isSwitch = true
            break
          i++
        if (isSwitch)
          str .= ';'

        # next line is indented
        elseif (tokens[n + 1]['indent'] > indent)
          # add opening bracket
          if (!in_array(tokens[n + 1]['str'], explode(' ', self.CONTINUING_LINE)))
            str .= '{'
            closingBrackets[] = indent
            openingBracket = false
          # save opening bracket
          else
            openingBracket = indent

        # line doesn't continue
        elseif (!in_array(tokens[n + 1]['str'], explode(' ', self.CONTINUING_LINE)))
          # there is saved opening bracket
          if (openingBracket !== false
              && tokens[n + 1]['indent'] > openingBracket)
            str .= '{'
            closingBrackets[] = openingBracket
            openingBracket = false
          # add semicolon
          else
            str .= ';'

        # add closing brackets
        if (indent > tokens[n + 1]['indent'])
          while (isset(closingBrackets[0])
              && closingBrackets[0] >= tokens[n + 1]['indent'])
            str .= '}'
            closingBrackets = array_slice(closingBrackets, 1)

      # convert php open tag
      if (type == T_OPEN_TAG)
        str = '<?php '
        if (y == 0)
          str .= self.OUTPUT_HEAD
      if (type == T_OPEN_TAG_WITH_ECHO)
        str = '<?php echo '

      # save token
      tokens[n] = token

    # glue code
    code = null
    foreach (tokens as n => token)
      code .= token['blank'] . token['str']

    # compress
    if (flags & self.COMPRESS)
      code = self.compress(code)

    # done
    return code

  # ---------------------------------------------
  # tokenize
  # ---------------------------------------------
  static fn tokenize(source)
    newTokens = []
    blank = null

    # get tokens
    tokens = token_get_all(source)

    # convert to associative arrays
    foreach (tokens as n => token)
      if (is_array(token))
        tokens[n] = ['str' => token[1], 'type' => token[0], 'name' => token_name(token[0])]
      else
        tokens[n] = ['str' => token, 'type' => null, 'name' => null]

    # save whitespaces and comments into tokens
    foreach (tokens as n => token)
      if (in_array(token['type'], [T_COMMENT, T_DOC_COMMENT, T_WHITESPACE, T_INLINE_HTML]))
        blank .= token['str']
      else
        token['blank'] = blank
        token['hasBlank'] = (blank != null)
        blank = null
        newTokens[] = token
    newTokens[] = ['str' => null, 'type' => null, 'blank' => blank]
    tokens = newTokens

    # get positions
    foreach (tokens as n => token)
      tokens[n]['n'] = n
      # first token
      if (n == 0)
        tokens[n]['indent'] = tokens[n]['x'] = tokens[n]['y'] = 0
        tokens[n]['isFirst'] = true
      # another token
      else
        # get y and relative x
        tokens[n]['x'] = mb_strlen(array_slice(explode("\n", token['blank']), -1)[0])
        tokens[n]['y'] = tokens[n - 1]['y'] + count(explode("\n", tokens[n - 1]['str'] . token['blank'])) - 1
        # set isFirst and isLast flags
        tokens[n]['isFirst'] = (tokens[n - 1]['y'] != tokens[n]['y'])
        tokens[n - 1]['isLast'] = (tokens[n - 1]['y'] != tokens[n]['y'])
        # get indent and absolute x
        if (tokens[n]['isFirst'])
          tokens[n]['indent'] = tokens[n]['x']
        if (!tokens[n]['isFirst'])
          tokens[n]['indent'] = tokens[n - 1]['indent']
          tokens[n]['x'] += tokens[n - 1]['x'] + mb_strlen(tokens[n - 1]['str'])
      # set isLast flag in last token
      if (n == count(tokens) - 1)
        tokens[n]['isLast'] = true

    # output
    return tokens


  # ---------------------------------------------
  # cacheFile
  # check cacheFile, parse if it's old
  # ---------------------------------------------
  static fn cacheFile(file, cacheFile, flags = 0)
    if (!is_dir(dirname(cacheFile)))
      mkdir(dirname(cacheFile), 0755, true)
    if (!is_file(cacheFile) || filemtime(cacheFile) <= filemtime(file) || flags & self.NOCACHE)
      file_put_contents(cacheFile, self.parseFile(file, null, flags))
    return cacheFile

  # ---------------------------------------------
  # parseFile
  # load file and parse it
  # ---------------------------------------------
  static fn parseFile(file, cacheFile = null, flags = 0)
    if (cacheFile == null)
      return self.parse(file_get_contents(file), flags)
    else
      return file_get_contents(self.cacheFile(file, cacheFile, flags))

  # ---------------------------------------------
  # includeFile
  # parse file and execute it
  # ---------------------------------------------
  static fn includeFile(file, cacheFile = null, flags = 0)
    if (cacheFile == null)
      return eval('?>' . self.parseFile(file, null, flags))
    else
      return require_once(self.cacheFile(file, cacheFile, flags))

  # ---------------------------------------------
  # testFile
  # parse file and show input and output as html
  # ---------------------------------------------
  static fn testFile(file, flags = 0)
    input = file_get_contents(file)
    output = self.parseFile(file, null, flags)
    pre = '<pre style="max-height:40em;max-width:30em;float:left;overflow:auto;font-size:12px;border:1px solid gray;padding:.2em;background-color:#fff">'
    html = '<div><h3 style="margin:0">' . file . '</h3>'
    foreach ([input, output] as text)
      html .= pre
      foreach (explode("\n", text) as n => line)
        html .= sprintf('%3d: %s', n, htmlspecialchars(line)) . "\n"
      html .= '</pre>'
    html .= '<hr style="height=0;border:none;clear:both"></div>'
    return html

  # ---------------------------------------------
  # compress
  # strip comments and compress php source
  # ---------------------------------------------
  static fn compress(php)
    space = output = null
    set = '!"#$&\'()*+,-./:;<=>?@[\]^`{|}'
    set = array_flip(preg_split('//', set))
    foreach (token_get_all(php) as token)
      if (!is_array(token))
        token = [0, token]
      if (in_array(token[0], [T_COMMENT, T_ML_COMMENT, T_DOC_COMMENT, T_WHITESPACE]))
        space = "\n"
      else
        if (isset(set[substr(output, -1)]) || isset(set[token[1]{0}]))
          space = null
        output .= space . token[1]
        space = null
    return output

