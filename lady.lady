<?

class Lady


  # ---------------------------------------------
  # constants
  # ---------------------------------------------
  const REGEX_CODE = '/.*[^(<\?|<\?php)\{\} ].*/'  # some php code on line
  const REGEX_OPEN_TAG = '/^ *(<\?|<\?php)/'       # <? or <?php
  const REGEX_COMMENT = '/^ *(#|\/\/).*/'          # full line comment
  const REGEX_EMPTY = '/^ *$/'                     # only spaces
  const REGEX_ENDED = '/[;&\|,\.]$/'               # no semicolons after these
  const REGEX_CONTINUE = '/^[&\|\.(->)]/'          # condition on multiple lines
  const REGEX_OPENING = '/(^[^(]*|.*\))$/'         # 'else' is opening
  const REGEX_VARIABLE = '/^[a-z].*/'              # variable name
  const REGEX_NOVARIABLE = '/^(false|true|self|null)$/' # not variables

  const PRESERVE = 0  # preserve code formating and comments
  const STRIP    = 1  # strip comments, keep line numbers
  const COMPRESS = 2  # compress output code

  const OUTPUT_HEAD = '# DO NOT EDIT THIS FILE. It was generated by LadyPHP.'
  const INDENT_WIDTH = 2


  # ---------------------------------------------
  # parse
  # convert lady script to php
  # ---------------------------------------------
  static public function parse(source, shrink = self::PRESERVE, debug = false)
    code = noVar = null
    dump = comment = array()

    # get tokens
    tokens = token_get_all(source)

    # convert string tokens to arrays
    foreach (tokens as n => token)
      if (!is_array(token))
        tokens[n] = array(null, token, null)
    
    # process tokens
    foreach (tokens as n => token)
      list(name, string, line) = token

      # convert `fn` to `function`
      if (name == T_STRING
          && string == 'fn')
        code .= 'function'

      # add `new` before `Foo()`
      elseif (name == T_STRING
          && tokens[n + 1][1] == '('
          && tokens[n - 2][0] != T_NEW
          && tokens[n - 1][0] != T_NS_SEPARATOR
          && !preg_match(self::REGEX_VARIABLE, string))
        code .= 'new ' . string

      # add $ to variables
      elseif (name == T_STRING
          && tokens[n + 1][1] != '('
          && tokens[n - 1][1] != '->'
          && tokens[n - 1][1] != '.'
          && preg_match(self::REGEX_VARIABLE, string)
          && !preg_match(self::REGEX_NOVARIABLE, string))
        code .= '$' . string

      # convert . to ->
      elseif (name == null
          && string == '.'
          && (tokens[n - 1][0] != T_WHITESPACE
              || tokens[n + 1][0] != T_WHITESPACE))
        code .= '->'

      # strip comments
      elseif (name == T_COMMENT)
        comments[line - 1] = string
        if (substr(string, -1) == "\n")
          code .= "\n"

      # convert php open tag
      elseif (name == T_OPEN_TAG)
        code .= '<?php '
        if (line == 1)
          code .= self::OUTPUT_HEAD

      # just copy
      else
        code .= string

      # save token dump
      if (debug)
        dump[] = line . ': ' . token_name(name) . ' =  ' . string

    # lines
    lines = explode("\n", code)
    indent = 0

    # shrink lines
    newLineNum = 0
    foreach (lines as n => line)
      if (!isset(emptyLines[newLineNum]))
        emptyLines[newLineNum] = null
      if (preg_match(self::REGEX_CODE, line))
        shrinkedLines[newLineNum] = line
        newLineNum++
      else 
        emptyLines[newLineNum] .= $line . "\n"
    shrinkedLines[] = 'true;'
    lines = shrinkedLines

    # edit lines
    foreach (lines as n => line)
      if (preg_match(self::REGEX_CODE, line)
          && !preg_match(self::REGEX_CONTINUE, trim(line)))
        indentBefore = indent
        indent = (strlen(line) - strlen(ltrim(line))) / self::INDENT_WIDTH
        jump = indent - indentBefore
      else 
        jump = 0

      # trim spaces
      spaceBefore = str_repeat(' ', strlen(line) - strlen(ltrim(line)))
      spaceAfter = str_repeat(' ', strlen(line) - strlen(rtrim(line)))
      line = trim(line)

      # add semicolon
      if (jump <= 0 
          && n > 0
          && !preg_match(self::REGEX_CONTINUE, line)
          && preg_match(self::REGEX_CODE, lines[n - 1])
          && !preg_match(self::REGEX_OPEN_TAG, lines[n - 1])
          && !preg_match(self::REGEX_COMMENT, lines[n - 1])
          && !preg_match(self::REGEX_ENDED, lines[n - 1])
          && !preg_match(self::REGEX_EMPTY, lines[n - 1]))
        lines[n - 1] .= ';'

      # add opening bracket
      if (jump > 0 && n > 0
          && preg_match(self::REGEX_OPENING, lines[n - 1]))
        lines[n - 1] .= '{'

      # add closing brackets
      if (jump < 0)
        lines[n - 1] .= str_repeat('}', -jump)

      # add spaces (PRESERVE)
      if (shrink < self::STRIP)
        line = spaceBefore . line . spaceAfter

      # change line
      lines[n] = line

    # add empty lines
    foreach (lines as n => line)
      lines[n] = emptyLines[n] . lines[n]

    # reindex lines
    lines = explode("\n", implode("\n", lines))

    # add comments (PRESERVE)
    if (shrink < self::STRIP)
      foreach (lines as n => line)
        if (isset(comments[n]))
          lines[n] = lines[n] . rtrim(comments[n])

    # trim spaces (STRIP and COMPRESS)
    else
      foreach (lines as n => line)
        lines[n] = rtrim(line, ' ')

    # format code
    code = implode("\n", array_slice(lines, 0, -1))

    # minify code (COMPRESS)
    if (shrink >= self::COMPRESS)
      code = self::compress(code)

    # output
    if (debug)
      NDebugger::barDump(dump, 'Lady tokens')
    return code
  

  # ---------------------------------------------
  # parseFile
  # load file and parse it
  # ---------------------------------------------
  static public function parseFile(file, shrink = self::PRESERVE, debug = false)
    return self::parse(file_get_contents(file), shrink, debug)
  

  # ---------------------------------------------
  # includeFile
  # parse file and execute it
  # ---------------------------------------------
  static public function includeFile(file)
    ob_start()
    eval('?>' . self::parseFile(file))
    return ob_get_clean()
  

  # ---------------------------------------------
  # compress
  # strip comments and compress php source
  # ---------------------------------------------
  static public function compress(input)
    if (!defined('T_DOC_COMMENT'))
      define('T_DOC_COMMENT', -1)
    if (!defined('T_ML_COMMENT'))
      define('T_ML_COMMENT', -1)

    space = output = ''
    set = '!"#$&\'()*+,-./:;<=>?@[\]^`{|}'
    set = array_flip(preg_split('//',set))

    foreach (token_get_all(input) as token)
      if (!is_array(token))
        token = array(0, token)

      if (in_array(token[0], array(T_COMMENT, T_ML_COMMENT, T_DOC_COMMENT, T_WHITESPACE)))
        space = ' '
      else
        if (isset(set[substr(output, -1)]) || isset(set[token[1]{0}]))
          space = ''
        output .= space . token[1]
        space = ''
    return output

